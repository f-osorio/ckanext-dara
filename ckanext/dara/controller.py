#Hendrik Bunke
#ZBW - Leibniz Information Centre for Economics


from ckan.controllers.package import PackageController
import ckan.plugins.toolkit as tk
from ckan.common import c, request, response
from ckan import model
import ckan.lib.helpers as h
from StringIO import StringIO
from lxml import etree
from darapi import DaraClient
from datetime import datetime
from hashids import Hashids
import random
from ckanext.dara.dara_schema_3_1 import schema

NotAuthorized = tk.NotAuthorized



class DaraController(PackageController):
    """
    displays and validates dara XML for the dataset or resource, and registers
    it at da|ra
    """
    

    def __init__(self):
        self.schema = schema
        
        
    def xml(self, id, template):
        """
        returning dara xml
        """
        response.headers['Content-Type'] = "text/xml; charset=utf-8"
        xml_string = tk.render(template)

        #validate before show. Errors are caught by lxml
        self._validate(xml_string)

        return xml_string
    
    
    def register(self, id, template):
        """
        register at da|ra
        """
        #XXX darapi is too small, should it be integrated here?
        
        ## using tk.c as context does not work here
        context = {'model': model, 'session': model.Session,
                   'user': c.user or c.author, 'for_view': True,
                   'auth_user_obj': c.userobj}
        data_dict = {'id': id}
    
        date = datetime.now()
        datestring = date.strftime("%Y-%m-%d-%H:%M:%S")

        try:
            tk.check_access('package_update', context, data_dict)
        except NotAuthorized:
            tk.abort(401, 'Unauthorized to manage DOI.')

        
        c.pkg_dict = tk.get_action('package_show')(context, data_dict)
                
        # test for parameters. For testserver DOI registration is not possible,
        # so we fake it (test_register)
        # defaults: register at 'real' server and get a DOI
        test = False
        register = True
        test_register = False
        
        req = tk.request
        param = req.params
        
        if 'testserver' in param:
            test = True
        if not 'DOI' in param:
            register = False
        if test and register:
            register = False
            test_register = True
        

        #XXX################################################################XXX
        resources = c.pkg_dict['resources']
        for res in resources:
            resource_id = res['id']
            if resource_id in param:
                c.resource = tk.get_action('resource_show')(context, {'id':resource_id})
                xml = self.xml(id, 'package/resource.xml')
                dara = DaraClient('demo', 'testdemo', xml, test=test,
                        register=register)
                dara = dara.calldara()
                if dara == 201 or 200:
                    doi  = u'%s.%s' %(c.pkg_dict['dara_DOI_Proposal'], res['dara_doiid']) 
                    c.resource['dara_DOI'] = doi
                    tk.get_action('resource_update')(context, c.resource)
                else:
                    h.flash_error("ERROR! Resource could not be registered\
                        (%s). Dataset has not been registered" %dara)
                    
                    tk.redirect_to('dara_doi', id=id)
        #XXX################################################################XXX

        #resources might have been updated so we must get a new collection package here
        c.pkg_dict = tk.get_action('package_show')(context, data_dict)
        
        xml = self.xml(id, template)
        dara = DaraClient('demo', 'testdemo', xml, test=test, register=register)
        dara = dara.calldara()
        
        if dara == 201:
            c.pkg_dict['dara_registered'] = datestring
            
            #Copy proposal to DOI
            #XXX we should eventually test if this is really true. Could perhaps be
            #done with getting and parsing the XML file generated by da|ra
            if register or test_register:
                c.pkg_dict['dara_DOI'] = c.pkg_dict['dara_DOI_Proposal']
            tk.get_action('package_update')(context, c.pkg_dict)
            h.flash_success("Dataset successfully registered.")
        elif dara == 200:
            c.pkg_dict['dara_updated'] = datestring
            if register or test_register:
                c.pkg_dict['dara_DOI'] = c.pkg_dict['dara_DOI_Proposal']
            tk.get_action('package_update')(context, c.pkg_dict)
            h.flash_success("Dataset successfully updated.")
        else:
            h.flash_error("ERROR! Sorry, dataset has not been registered or "
                    "updated. Please consult the logs. (%s) " %dara)

        tk.redirect_to('dara_doi', id=id)

    
    
    def doi(self, id):
        """
        DOI manager page
        """

        #XXX docs say that context is inherent. However, we do get wrong
        #breadcrumbs when not getting context here explicitly. Getting it with
        #toolkit.c throws error 'str is not callable'
        context = {'model': model, 'session': model.Session,
                   'user': c.user or c.author, 'for_view': True,
                   'auth_user_obj': c.userobj}
        data_dict = {'id': id}

        # Package needs to have a organization group in the call to
        # check_access and also to save it
        
        try:
            tk.check_access('package_update', context, data_dict)
        except NotAuthorized:
            tk.abort(401, 'Unauthorized to manage DOI.')


        c.pkg_dict = tk.get_action('package_show')(context, data_dict)
        c.pkg = context['package']
            
        template = "package/doi.html"
        page = tk.render(template)

        return page
    
    
    #XXX obsolete
   #def _create_doi(self, pkg_dict):
   #    """
   #    this should go in a function directly after package is created. 
   #    DOI would than be stored in pkg_dict and not created here. That way we 
   #    could use random ints. For now it only takes the pkg creation date and
   #    creates a unique hash of it. If there are more than one uploads in one second
   #    and for the same journal/organization we'd have a collision. This case
   #    might be rare ;-)
   #    """
   #    #XXX to be removed! deprecated. DOIs should be in pkg_dict

   #    prefix = u"10.2345" #XXX fake! change this. could be config
   #    
   #    org = pkg_dict['organization']
   #    journal = org['name']
   #    hashids = Hashids()
   #    created = pkg_dict['metadata_created'] #date string
   #    dt = datetime.strptime(created, "%Y-%m-%dT%H:%M:%S.%f") #object
   #    datestring = dt.strftime("%Y%m%d%H%M%S")
   #    
   #    date = int(datestring)
   #    num = hashids.encrypt(date)

   #    doi = prefix + '/' + journal + '.' + num

   #    return doi
   #
    
    #for old datasets or such where doi proposals are not saved for whatever
    #reason
    #XXX obsolete!!
   #def doi_proposal(self, id):
   #    
   #    try:
   #        tk.check_access('package_create', context)
   #    except NotAuthorized:
   #        tk.abort(401, 'Unauthorized to manage DOI')

   #    pkg = tk.get_action('package_show')(None, {'id': id})
   #    key = 'dara_DOI_Proposal'
   #    if key in pkg and pkg[key]:
   #        return "Has already DOI: %s" %pkg[key]
   #    doi = self._create_doi(pkg)
   #    tk.get_action('package_update')(None, {'id': id, 'dara_DOI_Proposal': doi})
   #    return 'Done!'
        
    
    def _validate(self, xmlstring):
        """
        validate against dara schema. errors are thrown by lxml
        """
        xml = StringIO(xmlstring)
        xsd = StringIO(self.schema)
        xmlschema_doc = etree.parse(xsd)
        xmlschema = etree.XMLSchema(xmlschema_doc)
        doc = etree.parse(xml)
        xmlschema.assertValid(doc)
    
       



